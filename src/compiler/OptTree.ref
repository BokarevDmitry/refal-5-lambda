$INCLUDE "LibraryEx";

*$FROM Config
$EXTERN Config-GetTreeOptCycles, Config-GetOptDrive, Config-GetOptSpec,
  Config-GetOptAutoMarkup, Config-GetOptIntrinsic;

*$FROM OptTree-AutoMarkup-Spec
$EXTERN OptTree-AutoMarkup-Spec;

*$FROM OptTree-AutoMarkup-Drive
$EXTERN OptTree-AutoMarkup-Drive, OptTree-AutoMarkup-CureDrives;

*$FROM OptTree-Drive
$EXTERN OptTree-Drive-Prepare, OptTree-Drive, OptTree-Drive-CleanupColdCalls;

*$FROM OptTree-Spec
$EXTERN OptTree-Spec-Prepare, OptTree-Spec, OptTree-Spec-CleanupColdFunctions;

*$FROM Log
$EXTERN Log-AST;


/**
  <OptTree t.Config e.AST> == e.OptAST

  e.OptAST не содержит разметки, описывающей прогоняемые, встраиваемые
  и специализируемые функции.
*/
$ENTRY OptTree {
  t.Config e.AST
    = <Config-GetTreeOptCycles t.Config> : s.Cycles
    = <Config-GetOptDrive t.Config> : s.OptDrive
    = <Config-GetOptSpec t.Config> : s.OptSpec
    = <Config-GetOptAutoMarkup t.Config> : s.OptAutoMarkup
    = <Config-GetOptIntrinsic t.Config> : s.OptIntrinsic

    = (s.OptDrive s.OptIntrinsic) : t.OptDrive
    = t.OptDrive
    : {
        (NoOpt NoOpt) = NoOpt;
        t.OptFlags = t.OptFlags;
      }
    : t.OptDriveFlags

    = <Int
        (define main
          (if s.OptAutoMarkup
            (begin
              (pass
                (trace 'before Auto markup')
                (call &OptTree-AutoMarkup-Spec)
                (call &OptTree-AutoMarkup-Drive))
              (DriveSpecLoop)
              (pass
                (trace 'before Driving transient instances')
                (call &OptTree-AutoMarkup-Drive))
              (call &OptTree-Drive-Prepare t.OptDrive)
              (DriveLoop))
            (begin
              (if t.OptDriveFlags
                (begin
                  (trace 'before Curing drives')
                  (call &OptTree-AutoMarkup-CureDrives))
                (begin))
              (DriveSpecLoop)))
          (call &OptTree-CleanupMarkup))

        (define DriveSpecLoop
          (if s.OptSpec
            (begin
              (call &OptTree-Drive-Prepare t.OptDrive)
              (call &OptTree-Spec-Prepare s.OptSpec)
              (loop-for-fix-point
                (DriveLoop)
                (pass
                  (trace 'before Spec')
                  (call &OptTree-Spec s.OptSpec)))
              (call &OptTree-Spec-CleanupColdFunctions))
            (begin
              (call &OptTree-Drive-Prepare t.OptDrive)
              (DriveLoop))))

        (define DriveLoop
          (if t.OptDriveFlags
            (begin
              (loop-for-fix-point
                (pass
                  (trace 'before Drive')
                  (call &ExpandClosures)
                  (call &OptTree-Drive t.OptDrive)))
              (call &OptTree-Drive-CleanupColdCalls))
            (call &ExpandClosures)))

        s.Cycles (e.AST)
      >
}


/**
  <OptTree-CleanupMarkup e.AST> == e.OptAST

  Удаляет метки $DRIVE, $INLINE, $INTRINSIC, $SPEC из дерева.
*/
$ENTRY OptTree-CleanupMarkup {
  e.AST
    = <Map
        {
          (Drive e.Name) = /* пропускаем */;
          (Inline e.Name) = /* пропускаем */;
          (Intrinsic e.Name) = /* пропускаем */;
          (Spec (e.Name) e.Pattern) = /* пропускаем */;

          (DriveInfo e.Info) = /* пропускаем */;
          (SpecInfo e.Info) = /* пропускаем */;

          t.Other = t.Other;
        }
        e.AST
      >
}


ExpandClosures {
  e.AST
    = <Map
        {
          (Function s.ScopeClass (e.Name) Sentences e.Body)
            = (Function
                s.ScopeClass (e.Name) Sentences
                <ExpandClosures-Body e.Body>
              );

          t.OtherItem = t.OtherItem;
        }
        e.AST
      >;
}

ExpandClosures-Body {
  e.Sentences = <Map &ExpandClosures-Sentence e.Sentences>;
}

ExpandClosures-Sentence {
  ((e.Pattern) e.Conditions (e.Result))
    = (
        (e.Pattern)
        <Map
          {
            (Condition (e.Name) (e.Result^) (e.Pattern^))
              = (Condition
                  (e.Name)
                  (<ExpandClosures-Result e.Result>)
                  (e.Pattern)
                );
          }
          e.Conditions
        >
        (<ExpandClosures-Result e.Result>)
      );
}

ExpandClosures-Result {
  e.Result = <Map &ExpandClusures-ResultTerm e.Result>;
}

ExpandClusures-ResultTerm {
  (Brackets e.Expr) = (Brackets <ExpandClosures-Result e.Expr>);

  (ADT-Brackets (e.Name) e.Expr)
    = (ADT-Brackets (e.Name) <ExpandClosures-Result e.Expr>);

  (CallBrackets (ClosureBrackets e.Content) e.Expr)
    = (CallBrackets <ExpandClosures-Result e.Content e.Expr>);

  (CallBrackets e.Expr) = (CallBrackets <ExpandClosures-Result e.Expr>);

  /*
    Анализировать холодные вызовы (ColdCallBrackets …) не нужно,
    поскольку они были проанализированы на предыдущих проходах
    и с тех пор не менялись.
  */

  t.OtherTerm = t.OtherTerm;
}

* Интерпретатор императивного кода оптимизаций


* TODO: удалить следующие пометки после оптимизации алгоритма оптимизации!
* Сейчас компиляция в режиме -OADiS для этого файла требует десятки минут.
$SPEC Int-Code e.arg;
$SPEC Int-Command e.arg;
$SPEC Int-FixPoint e.arg;


Int {
  e.Defines s.Cycles (e.AST)
    = e.Defines : (define s.StartPoint e._) e._
    = <Int-Code (e.Defines) (s.StartPoint) s.Cycles (e.AST)> : s.Cycles^ e.AST^
    = e.AST
}

Int-Code {
  (e.Defines) e.Code s.Cycles (e.AST)
    = e.Code
    : {
        t.Command e.Code^
          = <Int-Command (e.Defines) t.Command s.Cycles (e.AST)>
          : s.Cycles^ e.AST^
          = <Int-Code (e.Defines) e.Code s.Cycles (e.AST)>;

        /* empty */ = s.Cycles e.AST;
      }
}

Int-Command {
  (e.Defines) (e.Command) s.Cycles (e.AST)
    = e.Command
    : {
        pass e.Code
          = s.Cycles
          : {
              0 = 0 e.AST;

              s._
                = <Int-Code (e.Defines) e.Code s.Cycles (e.AST)> : s.Cycles^ e.AST^
                = <Dec s.Cycles> e.AST;
            };

        if NoOpt t.Then t.Else
          = <Int-Command (e.Defines) t.Else s.Cycles (e.AST)>;

        if t.Opt t.Then t.Else
          = <Int-Command (e.Defines) t.Then s.Cycles (e.AST)>;

        begin e.Code
          = <Int-Code (e.Defines) e.Code s.Cycles (e.AST)>;

        call s.Func e.Args
          = s.Cycles <s.Func e.Args e.AST>;

        trace e.Message
          = <Log-AST ('Pass ' <Symb s.Cycles> ' (' e.Message ')') e.AST> : e.AST^
          = s.Cycles e.AST;

        loop-for-fix-point e.Code
          = <Int-FixPoint (e.Defines) e.Code s.Cycles (e.AST)>;

        s.Proc
          = <Int-Lookup s.Proc e.Defines> : e.Code
          = <Int-Code (e.Defines) e.Code s.Cycles (e.AST)>;
      }
}

Int-FixPoint {
  (e.Defines) e.Code 0 (e.AST) = 0 e.AST;

  (e.Defines) e.Code s.Cycles (e.AST)
    = e.AST : e.OriginAST

    = <Int-Code (e.Defines) e.Code s.Cycles (e.AST)> : s.Cycles^ e.AST^

    = e.AST
    : {
        e.OriginAST = s.Cycles e.OriginAST;
        e.AST^ = <Int-FixPoint (e.Defines) e.Code s.Cycles (e.AST)>;
      };
}

$INLINE Int-Lookup;

Int-Lookup {
  s.ProcName (define s.ProcName e.Body) e._ = e.Body;
  s.ProcName t._ e.Defines = <Int-Lookup s.ProcName e.Defines>;
}
