$INCLUDE "LibraryEx";

*$FROM DisplayName
$EXTERN DisplayName;

*$FROM OptTree-AutoMarkup-Common
$EXTERN OptTree-AutoMarkup-Contains,
        OptTree-AutoMarkup-GetElemByKey;

/**
  <OptTree-AutoMarkup-ExtractFunctionCallsGraph e.AST>
    == e.FunctionCallsGraph (e.RootSet)

  e.RootSet ::= (e.FuncName)*
*/

$ENTRY OptTree-AutoMarkup-ExtractFunctionCallsGraph {
  e.AST
    = <SeparateMetatables e.AST> : (e.Metatables) e.Functions
    = <Map &MetatableReferences e.Metatables> : e.MetatablesRef
    = <Map &FunctionReferences e.Functions> : e.FunctionsRef

    = <InlineMetatableReferences e.FunctionsRef (e.MetatablesRef)>
    : e.FunctionsRef^

    = <SeparateIndirects e.FunctionsRef> : (e.Indirects) e.FunctionsRef^
    = <InlineIndirects e.FunctionsRef (e.Indirects)> : e.FunctionsRef^

    = <PrepareGraphFormat e.FunctionsRef> : (e.EntryPoints) e.Graph

    = <MapAccum
        {
          ((e.GraphNodes) (e.IndirectChildren))
          t.AstNode
            = <GetFuncs t.AstNode> : e.NodeOpt (e.NodeIndirectChildren)
            = (
                (e.GraphNodes e.NodeOpt)
                (e.IndirectChildren e.NodeIndirectChildren)
              );
        }
        ((/*graph nodes*/) (/*indirect children*/)) e.AST
      >
      : ((e.ExtractedFuncs) (e.IndirectChildren))
     = <Map &GetMetatablesNames e.AST>
      : e.MetatablesNames
    = <Unique e.IndirectChildren>
      : e.UniqueIndirectChildren
    = <Map
        {
          (e.FuncName)
            , e.MetatablesNames : e.MetatableHead (e.FuncName) e.MetatableTail
            = ;

          e.Other
            = e.Other;
        }
        e.UniqueIndirectChildren
      >
      : e.ClearedUniqueIndirectChildren
    = (Func
        (Indirect function for implicit calls)
        Children (e.ClearedUniqueIndirectChildren)
      )
      : t.IndirectFuncNode
    = <Map &GetMetatables e.AST>
      : e.ExtractedMetaTables
    = <InlineFuncCallsWithMetatable
        (e.ExtractedFuncs)
        (e.ExtractedMetaTables)
      >
      : e.InlinedGraph
    = <Map &GetEntryPoints e.AST>
      : e.EntryPoints2
    = <Unique e.EntryPoints e.Indirects> : e.Roots
    = <ReachableFunctions (e.Graph) (e.Roots)> : e.ResultGraph
    = e.ResultGraph (e.Roots);
}

SeparateMetatables {
  e.AST
    = <MapAccum
        {
          (e.Metatables) t.Function
            , t.Function : (Function s._ (e._) Metatable e._)
            = (e.Metatables t.Function) /* пусто */;

          (e.Metatables) t.Function
            , t.Function : (Function s._ (e._) Sentences e._)
            = (e.Metatables) t.Function;

          (e.Metatables) t._ = (e.Metatables) /* пропускаем */;
        }
        (/* metatables */)
        e.AST
      >
}

MetatableReferences {
  (Function s.ScopeClass (e.MetatableName) Metatable e.Metatable)
    = <Map
        {
          (t.FuncName-Word (Symbol Name e.Name)) = (Call e.Name);
        }
        e.Metatable
      >
    : e.References
    = ((e.MetatableName) s.ScopeClass e.References (INDIRECT));
}

FunctionReferences {
  (Function s.ScopeClass (e.Name) Sentences e.Sentences)
    = ((e.Name) s.ScopeClass <References-Body e.Sentences>)
}

References-Body {
  e.Sentences
    = <Map
        {
          ((e.Pattern) e.Conditions (e.Result))
            = <Unique
                <References-Expr e.Pattern>
                <Map
                  {
                    (Condition (e._) (e.CondResult) (e.CondPattern))
                      = <References-Expr e.CondResult>
                        <References-Expr e.CondPattern>
                  }
                >
                <References-Expr e.Result>
              >
        }
        e.Sentences
      >;
}

References-Expr {
  e.Expression = <Map &References-Term e.Expression>
}

References-Term {
  (CallBrackets (Symbol Name e.Name) e.Expr)
    = (Call e.Name) <References-Expr e.Expr>;

  (CallBrackets e.Expr) = (INDIRECT) <References-Expr e.Expr>;

  (Symbol Name e.Name) = (Pointer e.Name);

  (ADT-Brackets (e.Name) e.Expr) = <References-Expr e.Expr>;

  (s.Brackets e.Expr)
    , Brackets ClosureBrackets : e._ s.Brackets e._
    = <References-Expr e.Expr>;

  t.AnyOtherTerm = /* ничего интересного */;
}

InlineMetatableReferences {
  e.Functions (e.Metatables)
    = <Reduce
        {
          (e.Functions^) t.Metatable
            = (<InlineOneMetatable e.Functions t.Metatable>)
        }
        (e.Functions) e.Metatables
      >
    : (e.Functions^)
    = e.Functions;
}

InlineOneMetatable {
  e.Functions-B
  (
    (e.Name) s.ScopeClass
    e.References-B (Pointer e.MetatableName) e.References-E
  )
  e.Functions-E
  t.Metatable
    , t.Metatable : ((e.MetatableName) s._ e.MetatableReferences)
    = e.Functions-B
      (
        (e.Name) s.ScopeClass
        e.References-B e.MetatableReferences e.References-E
      )
      <InlineOneMetatable e.Functions-E t.Metatable>;

  e.Functions t.Metatable = e.Functions;
}

SeparateIndirects {
  e.Functions
    = <MapAccum
        {
          (e.Indirects)
          ((e.Name) s.ScopeClass e.References)

            = <SeparateIndirects-References e.References>
            : (e.FunctionIndirects) e.References^

            = (e.Indirects e.FunctionIndirects)
              ((e.Name) s.ScopeClass <Unique e.References>);
        }
        (/* indirects */)
        e.Functions
      >
    : (e.Indirects) e.Functions^
    = (<Unique e.Indirects>) e.Functions;
}

SeparateIndirects-References {
  e.References
    = <MapAccum
        {
          (e.Indirects) (Call e.Name) = (e.Indirects) (e.Name);
          (e.Indirects) (Pointer e.Name) = (e.Indirects (e.Name)) /* удаляем */;
          (e.Indirects) (INDIRECT) = (e.Indirects) INDIRECT;
        }
        (/* indirects */) e.References
      >
}

InlineIndirects {
  e.Functions-B
  ((e.Name) s.ScopeClass e.Children-B INDIRECT e.Children-E)
  e.Functions-E
  (e.Indirects)
    = e.Functions-B
      ((e.Name) s.ScopeClass <Unique e.Children-B e.Indirects e.Children-E>)
      <InlineIndirects e.Functions-E (e.Indirects)>;

  e.Functions (e.Indirects) = e.Functions;
}

PrepareGraphFormat {
  e.Functions
    = <MapAccum
        {
          (e.EntryPoints) ((e.Name) s.ScopeClass e.Children)
            = e.Name s.ScopeClass
            : {
                e._ GN-Entry = (e.Name);
                e._ s._, ('INIT') ('FINAL') : e._ (e.Name) e._ = (e.Name);
                e._ s._ = /* пропускаем */;
              }
            : e.NewEntryName
            = (e.EntryPoints e.NewEntryName)
              (Func (e.Name) Children (e.Children));
        }
        (/* entry points */) e.Functions
      >
}

GetEntryPoints {
  (Function GN-Entry (e.FuncName) Sentences e.Body)
    = (e.FuncName);

  (Function s.Scope (e.FuncName) Sentences e.Body)
    , <OneOf (e.FuncName) ('INIT') ('FINAL')> : True
    = (e.FuncName);

  t._ = /* пусто */;
}

ReachableFunctions {
* Очередная функция ещё не анализировалась, она есть в графе.
  (
    e.Graph-B (Func (e.NextName) Children (e.Children)) e.Graph-E
  )
  ((e.NextName) e.Unscanned)
    = (Func (e.NextName) Children (e.Children))
      <ReachableFunctions (e.Graph-B e.Graph-E) (e.Children e.Unscanned)>;

* Очередная функция или уже просканирована (удалена из графа),
* или не является функцией с предложениями.
  (e.Graph) ((e.NextName) e.Unscanned)
    = <ReachableFunctions (e.Graph) (e.Unscanned)>;

* Кончились несканированные функции.
* То, что осталось в графе, недоступно из корня.
  (e.Graph) (/* no unscanned */) = /* пусто */;
}

GetMetatables {
  (Function s.ScopeClass (e.Name) Metatable e.Metatable)
    = <Map
        {
          ((Symbol Identifier e.Ident) (Symbol Name e.Name^)) = (e.Name);
        }
        e.Metatable
      >
      : e.FunctionCalls
    = (e.Name (<Unique e.FunctionCalls>));

  t._other_node = /* пусто */;
}

GetMetatablesNames {
  (Function s.ScopeClass (e.Name) Metatable e.Metatable)
    = (e.Name);

  t._other_node = /* пусто */;
}

GetFuncs {
  (Function s.ScopeClass (e.Name) Sentences e.Body)
    = <MapAccum
        {
          ((e.DirectCalls)(e.ImplicitCalls)(e.IndirectChildren))
          (e.Sentence)
            = <ExtractFunctionCallsFromSentencesBody
                (e.Sentence)
              >
              : (e.SentenceDirectCalls)
                (e.SentenceImplicitCalls)
                (e.SentenceIndirectChildren)
            = (
                (e.DirectCalls e.SentenceDirectCalls)
                (e.ImplicitCalls e.SentenceImplicitCalls)
                (e.IndirectChildren e.SentenceIndirectChildren)
              )
        }
        ((/*direct calls*/) (/*implicit calls*/) (/*indirect children*/))
        e.Body
      >
      : ((e.DirectCalls) (e.ImplicitCalls) (e.IndirectChildren))
    = <Unique e.DirectCalls> : e.UniqueDirectCalls
    = (e.ImplicitCalls)
      : {
          ()
            = ;

          (e._)
            = (Indirect function for implicit calls)
        }
        : e.IndirectChild
    = (Func (e.Name) Children (e.UniqueDirectCalls e.IndirectChild))
      (e.IndirectChildren);

  t._other_node = /* нет узлов */ (/* нет косвенных потомков */);
}

ExtractFunctionCallsFromSentencesBody {
  ((e.Pattern) e.Conditions (e.Result))
    = <ExtractExpressionName e.Pattern>
      : (e.PatternNames) (e.PatternIndirectCalls) (e.PatternIndirectChildren)
    = <Reduce
        {
          ((e.DirectCalls)(e.IndirectCalls)(e.IndirectChildren))
          (Condition (e.Name) (e.ConditionResult) (e.ConditionPattern))
              = <ExtractExpressionName
                  e.ConditionResult
                >
                : (e.ConditionResultCalls)
                  (e.ConditionResultIndirectCalls)
                  (e.ConditionResultIndirectChildren)
              = <ExtractExpressionName
                  e.ConditionPattern
                >
                : (e.ConditionPatternCalls)
                  (e.ConditionPatternIndirectCalls)
                  (e.ConditionPatternIndirectChildren)
              = (
                  (
                    e.DirectCalls
                    e.ConditionResultCalls
                    e.ConditionPatternCalls
                  )
                  (
                    e.IndirectCalls
                    e.ConditionResultIndirectCalls
                    e.ConditionPatternIndirectCalls
                  )
                  (
                    e.IndirectChildren
                    e.ConditionResultIndirectChildren
                    e.ConditionPatternIndirectChildren
                  )
                );
        }
        ((/*direct calls*/) (/*indirect calls*/) (/*indirect children*/))
        e.Conditions
      >
      : (
          (e.ConditionNames)
          (e.ConditionIndirectCalls)
          (e.ConditionIndirectChildren)
        )
    = <ExtractExpressionName e.Result>
      : (e.ResultNames) (e.ResultIndirectCalls) (e.ResultIndirectChildren)
    = (
        e.PatternNames
        e.ConditionNames
        e.ResultNames
      )
      (
        e.PatternIndirectCalls
        e.ConditionIndirectCalls
        e.ResultIndirectCalls
      )
      (
        e.PatternIndirectCalls
        e.ConditionIndirectChildren
        e.ResultIndirectChildren
      );
}

InnerExtractExpressionName {
  (e.Expr) (e.DirectCalls) (e.IndirectDetected) (e.IndirectChildren)
    = <MapAccum
        {
          ((e.DirectCalls^) (e.IndirectDetected^) (e.IndirectChildren^))
          (Symbol Name e.Name)
            = (
                (e.DirectCalls (e.Name))
                (e.IndirectDetected)
                (e.IndirectChildren)
              );

          ((e.DirectCalls^) (e.IndirectDetected^) (e.IndirectChildren^))
          (s.Marker e.Nested)
            , <OneOf
                (s.Marker)
                (Brackets)
                (ADT-Brackets)
                (ClosureBrackets)
              > : True
            = <InnerExtractExpressionName
                (e.Nested)
                (e.DirectCalls)
                (e.IndirectDetected)
                (e.IndirectChildren)
              >;

          ((e.DirectCalls^) (e.IndirectDetected^) (e.IndirectChildren^))
          (CallBrackets
            (Symbol Name e.Name)
            e.NestedHead
            (Symbol Name e.IndirectChild)
            e.NestedTail
          )
            = (e.IndirectChild)
              <Map
                {
                  (Symbol Name e.NextInderectChild)
                    = (e.NextInderectChild);

                  e.Other
                    = ;
                }
                e.NestedTail
              >
              : e.AdditionaIndirectChildren
            = <Map
                {
                  (Symbol Name e._)
                    = ;

                  e.Other
                    = e.Other;
                }
                e.NestedHead e.NestedTail
              >
              : e.Nested^
            = <InnerExtractExpressionName
                (e.Nested)
                (e.DirectCalls)
                (e.IndirectDetected)
                (e.IndirectChildren)
              >
              : (
                  (e.DirectCalls^)
                  (e.IndirectDetected^)
                  (e.IndirectChildren^)
                )
            = (
                (e.DirectCalls (e.Name))
                (e.IndirectDetected)
                (e.IndirectChildren e.AdditionaIndirectChildren)
              );

          ((e.DirectCalls^) (e.IndirectDetected^) (e.IndirectChildren^))
          (CallBrackets (Symbol Name e.Name) e.Nested)
            = <InnerExtractExpressionName
                (e.Nested)
                (e.DirectCalls)
                (e.IndirectDetected)
                (e.IndirectChildren)
              >
              : (
                  (e.DirectCalls^)
                  (e.IndirectDetected^)
                  (e.IndirectChildren^)
                )
            = (
                (e.DirectCalls (e.Name))
                (e.IndirectDetected)
                (e.IndirectChildren)
              );

          ((e.DirectCalls^) (e.IndirectDetected^) (e.IndirectChildren^))
          (CallBrackets e.Nested)
            = <InnerExtractExpressionName
                (e.Nested)
                (e.DirectCalls)
                (e.IndirectDetected)
                (e.IndirectChildren)
              >
              : (
                  (e.DirectCalls^)
                  (e.IndirectDetected^)
                  (e.IndirectChildren^)
                )
            = (
                (e.DirectCalls)
                (Indirect detected)
                (e.IndirectChildren)
              );

          ((e.DirectCalls^) (e.IndirectDetected^) (e.IndirectChildren^))
          (t.Marker e.Smth)
            = ((e.DirectCalls) (e.IndirectDetected) (e.IndirectChildren));
        }
        ((e.DirectCalls) (e.IndirectDetected) (e.IndirectChildren))
        e.Expr
      >;
}

ExtractExpressionName {
  e.Expr
    = <InnerExtractExpressionName (e.Expr) () () ()>
      : ((e.DirectCalls) (e.IndirectDetected) (e.IndirectChildren))
    = (e.DirectCalls) (e.IndirectDetected) (e.IndirectChildren)
}

InlineFuncCallsWithMetatable {
  (e.ExtractedFuncs) (e.ExtractedMetaTables)
    = <Map
        {
          t.Elem
            = <InlineOneFuncChildrenWithMetatable
                t.Elem
                (e.ExtractedMetaTables)
              >;
        }
        e.ExtractedFuncs
      >;
}

InlineOneFuncChildrenWithMetatable {
  (Func (e.Name) Children (e.UniqueFunctionCalls)) (e.ExtractedMetaTables)
      = <Map
          {
            t.Elem
              = <GetCallsFromMetaTables
                  t.Elem
                  (e.ExtractedMetaTables)
                >;
          }
          e.UniqueFunctionCalls
        >
        : e.ReplacedChildren
      = <Unique e.ReplacedChildren>
        : e.UniqueReplacedChildren
      = (Func (e.Name) Children (e.UniqueReplacedChildren));
}

GetCallsFromMetaTables {
  (e.FuncName) (e.ExtractedMetaTables)
    = (<Map
        {
          (e.Key (e.Value))
            , e.Key : e.FuncName
            = e.Value;

          (e.Other)
            = ;
        }
        e.ExtractedMetaTables
      >)
      : e.ReplaceValue
    = <Fetch
        e.ReplaceValue
        {
          ()
            = (e.FuncName);

          (e.FuncSet)
            = e.FuncSet;
        }
      >;
}
