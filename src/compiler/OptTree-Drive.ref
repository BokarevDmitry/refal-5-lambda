$INCLUDE "LibraryEx";


*$FROM TreeUtils
$EXTERN ExtractVariables;

*$FROM GenericMatch
$EXTERN Solve;

*$FROM Log
$EXTERN Log-PutLine;

*$FROM DisplayName
$EXTERN DisplayName;


/*
  В дерево добавляется узел (DriveInfo e.DriveInfo).

  e.DriveInfo ::= (e.OptFuncNames (e.OptFunctions))
  e.OptFuncNames ::= (e.Name)*
  e.OptFunctions ::= t.OptFunction

  t.OptFunction ::= (s.Label s.ScopeClass (e.Name) e.OptBody)
  e.OptBody ::= Sentences e.Sentences
*/


/**
  <OptTree-Drive-Prepare (s.OptDrive s.OptIntrinsic) e.AST> == e.AST

  s.OptDrive ::= OptDrive | OptInline | NoOpt
  s.OptIntrinsic ::= OptIntrinsic | NoOpt
*/
$ENTRY OptTree-Drive-Prepare {
  (NoOpt NoOpt) e.AST = e.AST;

  (s.OptDrive s.OptIntrinsic)
  e.AST-B (DriveInfo e.DriveInfo) e.AST-E
    = <UpdateDriveInfo s.OptDrive s.OptIntrinsic (e.DriveInfo) e.AST-B e.AST-E>;

  (s.OptDrive s.OptIntrinsic) e.AST
    = (/* no names */) /* no info */ : e.EmptyInfo
    = <UpdateDriveInfo s.OptDrive s.OptIntrinsic (e.EmptyInfo) e.AST>;
}

/**
  <OptTree-Drive (s.OptDrive s.OptIntrinsic) e.AST> == e.AST^
*/
$ENTRY OptTree-Drive {
  (NoOpt NoOpt) e.AST = e.AST;

  (s.OptDrive s.OptIntrinsic) e.AST-B (DriveInfo e.DriveInfo) e.AST-E
    = <DriveInlineOptimizerTick
        (e.DriveInfo) e.AST-B e.AST-E s.OptDrive s.OptIntrinsic
      >
}

/* Функция генерирует имена остаточных прогоняемых функций */

GenRemainderFuncNames {
  e.Name 0 = /* пусто */;

  e.Name s.LastCount
    , e.Name
    : {
        e.ProperName SUF e.Suffix = e.Name '*' s.LastCount;
        e.ProperName = e.ProperName SUF '*' s.LastCount;
      }
    : e.NewName
    = <GenRemainderFuncNames e.Name <Dec s.LastCount>> (e.NewName);
}

UpdateDriveInfo {
  s.OptDrive s.OptIntrinsic ((e.KnownNames) e.KnownFunctions) e.AST

    /* Выносим все Drive, Inline, Intrinsic, Metatable из дерева */
    = <MapAccum
        {
          (e.Optimizable) (Drive e.Name) = (e.Optimizable (Drive e.Name));
          (e.Optimizable) (Inline e.Name) = (e.Optimizable (Inline e.Name));
          (e.Optimizable) (Intrinsic e.Name) = (e.Optimizable (Intrinsic e.Name));
          (e.Optimizable) (Function s.ScopeClass (e.Name) Metatable e.Body)
           = (e.Optimizable (Metatable e.Name)) (Function s.ScopeClass (e.Name) Metatable e.Body);
          (e.Optimizable) t.Other = (e.Optimizable) t.Other;
        }
        () e.AST
      >
    : (e.OptNames) e.AST^

    = <SetNames-Reject (e.OptNames) (e.KnownNames)> : e.OptNames^

    /*
      Выделяем тела оптимизируемых функций,
      копировать несколько имён в e.OptimizableNames не страшно

      Используем MapAccum не смотря на то, что достаточно Map:
      избегаем копирования дерева
    */
    = <Map
        {
          (s.Label e.Name)
            = '$' <Upper <Explode s.Label>> : e.Label
            = <Log-PutLine 'New ' e.Label ' function: ' <DisplayName e.Name>>;
        }
        e.OptNames
      >
      <MapAccum
        {
          (
            (e.OptFunctions) (e.RemNames)
            (e.OptNames-B (s.Label e.Name) e.OptNames-E)
          )
          (Function s.ScopeClass (e.Name) s.BodyLabel e.Body)
          , <OneOf s.Label Intrinsic Metatable> : True
            = s.Label : {
              Intrinsic = e.Name;
              Metatable = e.Body
            } : e.OptFunctionBody
            =
            (
              (
                e.OptFunctions
                (s.Label s.ScopeClass (e.Name) s.Label e.OptFunctionBody)
              )
              (
                e.RemNames
                (e.Name)
              )
              (e.OptNames-B e.OptNames-E)
            )
            (Function s.ScopeClass (e.Name) s.BodyLabel e.Body);

          (
            (e.OptFunctions) (e.RemNames)
            (e.OptNames-B (s.Label e.Name) e.OptNames-E)
          )
          (Function s.ScopeClass (e.Name) Sentences e.Sentences)
            = <Lenw e.Sentences> : s.CountSentences e.Sentences^
            = (
                (
                  e.OptFunctions
                  (s.Label s.ScopeClass (e.Name) Sentences e.Sentences)
                )
                (
                  e.RemNames
                  (e.Name)
                  <GenRemainderFuncNames e.Name s.CountSentences>
                )
                (e.OptNames-B e.OptNames-E)
              )
              (Function s.ScopeClass (e.Name) Sentences e.Sentences);

          (e.OptInfo) t.Other
            = (e.OptInfo) t.Other;
        }
        (() () (e.OptNames)) e.AST
      >
    : ((e.OptFunctions) (e.DrivenNames) (e._)) e.AST^

    = (DriveInfo (e.KnownNames e.DrivenNames) e.KnownFunctions e.OptFunctions)
      e.AST;
}

SetNames-Reject {
  (e.Minuent-B (s._M e.Name) e.Minuent-E) (e.Subtr-B (s.Label e.Name) e.Subtr-E)
    = e.Minuent-B
      <SetNames-Reject (e.Minuent-E) (e.Subtr-B (s.Label e.Name) e.Subtr-E)>;

  (e.Minuent) (e.Subtrahend) = e.Minuent;
}

OptSwitch {
  OptDrive = Drive;
  OptInline = Inline;
  OptIntrinsic = Intrinsic;
  NoOpt = None
}

/* Осуществляет прогонку или оптимизацию в зависимости от ключа */

DriveInlineOptimizerTick {
  t.OptInfo e.AST s.OptDrive s.OptIntrinsic
    = (<OptSwitch s.OptDrive> <OptSwitch s.OptIntrinsic>) : t.Mode
    = <MapAccum
        {
          t.OptInfo^ (Function s.ScopeClass (e.Name) Sentences e.Sentences)
            = <OptFunction
                (Function s.ScopeClass (e.Name) Sentences e.Sentences)
                t.OptInfo
                t.Mode
              >;

          t.OptInfo^ t.Other = t.OptInfo t.Other
        }
        t.OptInfo
        e.AST
      >
    : (e.OptInfo) e.AST^

    = <MapAccum
        {
          (e.News-B (Function s.ScopeClass (e.Name) e.Body) e.News-E)
          (NewFunction s.ScopeClass (e.Name) e._)
            = (e.News-B (Function s.ScopeClass (e.Name) e.Body) e.News-E)
              /* пропускаем */;

          (e.NewFunctions) (NewFunction s.ScopeClass (e.Name) e.Body)
            = (e.NewFunctions (Function s.ScopeClass (e.Name) e.Body));

          (e.NewFunctions) t.Other = (e.NewFunctions) t.Other;
        }
        (/* new functions */) e.AST
      >
    : (e.NewFunctions) e.AST^

    = <MapAccum
        {
          (e.News-B (Function s.ScopeClass (e.Name) e._) e.News-E)
          (s.Function s.ScopeClass (e.Name) e.Body)
            , <OneOf s.Function Function ColdFunction> : True
            = (e.News-B e.News-E)
              (s.Function s.ScopeClass (e.Name) e.Body);

          (e.NewFunctions^) t.Other = (e.NewFunctions) t.Other;
        }
        (e.NewFunctions) e.AST
      >
    : (e.NewFunctions^) e.AST^

    = (DriveInfo e.OptInfo) e.AST e.NewFunctions;
}

IsPassiveCall {
  e.Expr
    = <Reduce
        {
           True t.Term = <IsPassiveCall-Aux t.Term>;
           False t.Term = False;
        }
        True
        e.Expr
      >

}

IsPassiveCall-Aux {
  (Brackets e.Expr) = <IsPassiveCall e.Expr>;
  (ADT-Brackets e.Expr) = <IsPassiveCall e.Expr>;

  (CallBrackets e.Expr) = False;
  (ColdCallBrackets e.Expr) = False;

  t.Other = True;
}

IsLexpr {
  e.Expr
    , <IsLexpr-Aux e.Expr>
    : {
        e.Res-B OpenE e.Res-E = False;
        e.Res-B (s.Mode e.Index) e.Res-M (s.Mode e.Index) e.Res-E = False;
        e.Other = True;
      }
}

/*
  <IsLexpr-Aux e.Expr> == t.IsLexpr-Aux-Item*

  t.IsLexpr-Aux-Item ::= OpenE | ('e' e.Index) | ('t' e.Index)
*/
IsLexpr-Aux {
  e.Expr-B (TkVariable 'e' e.Index1) e.Expr-M (TkVariable 'e' e.Index2) e.Expr-E
    = OpenE;

  e.Expr
    = <Map
        {
          (TkVariable 'e' e.Index) = ('e' e.Index);
          (TkVariable 't' e.Index) = ('t' e.Index);

          (Brackets e.InBrackets) = <IsLexpr-Aux e.InBrackets>;
          (ADT-Brackets (e.Name) e.InBrackets) = <IsLexpr-Aux e.InBrackets>;

          t.Other = /* пропускаем */;
        }
        e.Expr
      >;
}

/*
  Осуществляет попытку прогонки или встраивания в функции
  <OptFunction t.Function t.DriveInfo s.Mode>
    == t.DriveInfo t.OptimizedFunction t.Function*

  Возвращает модифицированную функцию
  и порожденные из прогонки или встраивания
*/

OptFunction {
  (Function s.ScopeClass (e.Name) Sentences e.Sentences)
  t.OptInfo t.Mode
    = <Reduce
        {
          (t.OptInfo^ (e.SntAcc) (e.FunAcc)) t.Sentence
            = <OptSentence t.Sentence t.OptInfo t.Mode>
            : t.OptInfo^ (e.NewFunctions) e.NewSentences
            = (t.OptInfo (e.SntAcc e.NewSentences) (e.FunAcc e.NewFunctions));
        }
        (t.OptInfo (/*sentences*/) (/*functions*/))
        e.Sentences
      >
    : (t.OptInfo^ (e.Sentences^) (e.NewFunctions))
    = t.OptInfo
      (Function s.ScopeClass (e.Name) Sentences e.Sentences) e.NewFunctions;
}

/*
   <OptSentence t.Sentence t.OptInfo s.Mode>
   == t.OptInfo (t.Func?) t.Sentence*
*/

OptSentence {
  /* Оптимизируем только предложения вида Pat = Res */
  ((e.Left) (e.Right)) ((e.OptFuncNames) e.OptFuncs) t.Mode
     = <FindOptimizedCall (e.OptFuncNames) e.Right>
     : {
         (e.OptFuncNames^ None) e.Right^
           = ((e.OptFuncNames) e.OptFuncs) () ((e.Left) (e.Right));

         (e.OptFuncNames^ t.Call) e.Right^
           = <OptSentence-Aux t.Mode ((e.Left) (e.Right)) t.Call e.OptFuncs>
           : (e.OptFuncs^) (e.NewFunctions) e.NewSentences
           = ((e.OptFuncNames) e.OptFuncs) (e.NewFunctions) e.NewSentences
       };

  t.Sentence t.OptInfo t.Mode = t.OptInfo () t.Sentence
}

OptSentence-Aux {
  (s.DriveMode s.IntrinsicMode)
  ((e.Left) (e.Right))
  (CallBrackets (Symbol Name e.Name) e.Args)
  e.OptFuncs

    /* Поиск информации для прогонки */
    = <FindOptInfo e.OptFuncs (e.Name)> : e.OptFuncs^ t.FunctionForDrive
    = s.IntrinsicMode : {
      Intrinsic = <FindMetatables e.OptFuncs>;
      s._ = ()
    } : t.Metatables
    = <OptSentence-MakeSubstitutions
      (s.DriveMode s.IntrinsicMode) ((e.Left) (e.Right)) (e.Args) t.FunctionForDrive t.Metatables
      >
    : e.SolutionPacks

    = (e.OptFuncs)
      <MapAccum
        {
          (e.NewFunctions) ((e.RS^) e.Solutions^ (e.NewFunction))
            = (e.NewFunctions e.NewFunction)
              <ApplySolutions ((e.Left) (e.Right)) (e.RS) e.Solutions>;
        }
        (/* new functions */)
        e.SolutionPacks
      >;
}


ArithmeticFunctions {
  = ('Add') ('Div') ('Divmod') ('Mod') ('Mul') ('Sub') ('Compare');
}

SymbolsToNumber {
  e.Symbols = <Map
    {
      (Symbol Char '-') = '-';
      (Symbol Char '+') = '+';
      (Symbol Number s.n) = s.n
    }
    e.Symbols
  >
}

NumberToSymbols {
  e.Number = <Map
    {
      '-' = (Symbol Char '-');
      '+' = (Symbol Char '+');
      s.n = (Symbol Number s.n)
    }
    e.Number
  >
}

NodeToChar {
  e.Node = <Map {
    (Symbol Char s.a) = s.a
  } e.Node>
}

CharToNode {
  e.Char = <Map {
    s.a = (Symbol Char s.a)
  } e.Char>
}


CheckArgs-Intrinsic-StaticSubstitution {
  (e.Args) s.SymbolName =
  e.Args : {
    (Symbol s.SymbolName e.Name) e.Rest = <CheckArgs-Intrinsic-StaticSubstitution (e.Rest) s.SymbolName>;
    (TkVariable e.Var) e.Rest = <CheckArgs-Intrinsic-StaticSubstitution (e.Rest) s.SymbolName>;
    (ColdCallBrackets e.Body) e.Rest =  <CheckArgs-Intrinsic-StaticSubstitution (e.Rest) s.SymbolName>;
    t.Other e.Rest = False;
    = True;
  }
}

StaticSubstitution {
  (e.Args) (e.FuncName) s.Func s.SymbolFrom s.SymbolTo =
  <MapAccum
    {
      (e.Result) (Symbol s.SymbolFrom s.n) e.Rest = (e.Result (Symbol s.SymbolTo <s.Func s.n>)) e.Rest;
      (e.Result) (TkVariable e.Var) e.Rest = (e.Result (ColdCallBrackets (Symbol Name e.FuncName) (TkVariable e.Var))) e.Rest;
      (e.Result) (ColdCallBrackets e.Body) e.Rest = (e.Result (ColdCallBrackets (Symbol Name e.FuncName) (ColdCallBrackets e.Body))) e.Rest
    }
    () e.Args
  > : (e.Result) e._
  = e.Result
}

CheckArgs-Intrinsic {
  (e.Args) s.SymbolName =
  e.Args : {
    (Symbol s.SymbolName e.Name) e.Rest = <CheckArgs-Intrinsic (e.Rest) s.SymbolName>;
    t.Other e.Rest = False;
    = True;
  }
}

CheckArgs-Intrinsic-Symb {
  (Symbol Char e.Name) e.Rest = <CheckArgs-Intrinsic-Symb e.Rest>;
  (Symbol Number e.Name) e.Rest = <CheckArgs-Intrinsic-Symb e.Rest>;
  t.Other e.Rest = False;
  = True;
}

CheckArgs-Intrinsic-EVariable {
  (Symbol s.SymbolName e.Name) e.Rest = <CheckArgs-Intrinsic-EVariable e.Rest>;
  (Brackets e.Body) e.Rest = <CheckArgs-Intrinsic-EVariable e.Rest>;
  (TkVariable s.Mode e.VarName) e.Rest, <OneOf s.Mode 't' 's'> : True = <CheckArgs-Intrinsic-EVariable e.Rest>;
  t.Other e.Rest = False;
  = True;
}

SignedArithmeticResult {
  s.Res e.ResSign
  = e.ResSign : {
    s.ResSignChar = (Symbol Char s.ResSignChar) (Symbol Number s.Res);
    = (Symbol Number s.Res)
  } : e.Result
  = (
    (e.Result) (()()) ()
  )
}

SignedResult-Divmod {
  (e.QSign s.Q) e.RSign s.R
  = e.QSign : {
    s.QSignChar = e.RSign : {
      s.RSignChar = (Brackets (Symbol Char s.QSignChar) (Symbol Number s.Q)) (Symbol Char s.RSignChar) (Symbol Number s.R);
      = (Brackets (Symbol Char s.QSignChar) (Symbol Number s.Q)) (Symbol Number s.R)
    };
    = e.RSign : {
      s.RSignChar = (Brackets (Symbol Number s.Q)) (Symbol Char s.RSignChar) (Symbol Number s.R);
      = (Brackets (Symbol Number s.Q)) (Symbol Number s.R)
    }
  } : e.Res
  = (
    (e.Res) (()()) ()
  )
}

MakeSubstitution-FromMetatables {
  t.Metatables (e.MetatableName) t.IntrinsicFunction (e.Args) (e.MuArg) e.Name =
  t.Metatables : {
    (e._ (Metatable s.ScopeClass (e.MetatableName)
    Metatable e.Left ((Symbol Identifier e.Name) t.SymbolName) e.Right) e._) = (
      ((CallBrackets t.SymbolName e.MuArg))
      (()()) ()
    );
    e.Other = <MakeColdSolution t.IntrinsicFunction e.Args>
  }
}

ArithmeticSymbolToFunction {
    '+' = 'Add';
    '-' = 'Sub';
    '/' = 'Div';
    '*' = 'Mul';
    '%' = 'Divmod';
    '?' = 'Mod'
}

DoOptSentence-MakeSubstitutions-Intrinsic {
  t.IntrinsicFunction t.Metatables (e.Args) e.BehaviorName =
  e.BehaviorName : {
    '__Meta_Mu' =
      e.Args : {
      t.Function e.MuArg (Symbol Name e.MetatableName) =
      t.Function : {
        (Symbol Name e.Name) = (
          ((CallBrackets (Symbol Name e.Name) e.MuArg))
          (()()) ()
        );

        (ClosureBrackets e.Body) =
        (
          ((CallBrackets (ClosureBrackets e.Body) e.MuArg))
          (()()) ()
        );

        (Symbol Identifier s.Name), <OneOf s.Name '+-/%*?'> : True
        = <ArithmeticSymbolToFunction s.Name> : e.FunctionName
        = (
          ((CallBrackets (Symbol Name e.FunctionName) e.MuArg))
          (()()) ()
        );

        (Symbol Char s.Name), <OneOf s.Name '+-/%*?'> : True
        = <ArithmeticSymbolToFunction s.Name> : e.FunctionName
        = (
          ((CallBrackets (Symbol Name e.FunctionName) e.MuArg))
          (()()) ()
        );

        (Symbol Identifier e.Name)= <MakeSubstitution-FromMetatables t.Metatables (e.MetatableName) t.IntrinsicFunction (e.Args) (e.MuArg) e.Name>;

        (Brackets e.Chars) = <MapAccum
            {
              (e.Result) (Symbol Char s.1) e.Rest = (e.Result s.1) e.Rest;
            }
            () e.Chars
          > : (e.Name) e._
          = <MakeSubstitution-FromMetatables t.Metatables (e.MetatableName) t.IntrinsicFunction (e.Args) (e.MuArg) e.Name>;

        e._ = <MakeColdSolution t.IntrinsicFunction e.Args>
      };

      e.Other = <MakeColdSolution t.IntrinsicFunction e.Args>
    };

    'Add' = e.Args : {
      (Brackets e.Numbers1) e.Numbers2 =
        <Add (<SymbolsToNumber e.Numbers1>) <SymbolsToNumber e.Numbers2>> : e.Result
        = <NumberToSymbols e.Result> : e.Result^
        =
        (
          (e.Result) (()()) ()
        );

      (Symbol Number 0) (ColdCallBrackets (Symbol Name e.Name) e.Body),
      <OneOf (e.Name) <ArithmeticFunctions>> : True =
        (
          ((ColdCallBrackets (Symbol Name e.Name) e.Body)) (()()) ()
        );

      (ColdCallBrackets (Symbol Name e.Name) e.Body) (Symbol Number 0),
      <OneOf (e.Name) <ArithmeticFunctions>> : True =
      (
        ((ColdCallBrackets (Symbol Name e.Name) e.Body)) (()()) ()
      );

      e.Sign1 (Symbol Number s.1) e.Sign2 (Symbol Number s.2) =
      e.Sign1 : {
        (Symbol Char s.sign1)
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Add s.sign1 s.1 s.sign2 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>;

            = <Add s.sign1 s.1 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>
        };
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Add s.1 s.sign2 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>;

            = (
              ((Symbol Number <Add s.1 s.2>)) (()()) ()
            );
        }
      };

      e._  = <MakeColdSolution t.IntrinsicFunction e.Args>
    };

    'Sub' = e.Args : {
      (Brackets e.Numbers1) e.Numbers2 =
        <Sub (<SymbolsToNumber e.Numbers1>) <SymbolsToNumber e.Numbers2>> : e.Result
        = <NumberToSymbols e.Result> : e.Result^
        =
        (
          (e.Result) (()()) ()
        );

      (ColdCallBrackets (Symbol Name e.Name) e.Body) (Symbol Number 0),
      <OneOf (e.Name) <ArithmeticFunctions>> : True =
      (
        ((ColdCallBrackets (Symbol Name e.Name) e.Body)) (()()) ()
      );

      e.Sign1 (Symbol Number s.1) e.Sign2 (Symbol Number s.2) =
      e.Sign1 : {
        (Symbol Char s.sign1)
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Sub s.sign1 s.1 s.sign2 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>;

            = <Sub s.sign1 s.1 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>
        };
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Sub s.1 s.sign2 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>;

            = <Sub s.1 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>
        }
      };

      e._  = <MakeColdSolution t.IntrinsicFunction e.Args>
    };

    'Mul' = e.Args : {
      (Brackets e.Numbers1) e.Numbers2 =
        <Mul (<SymbolsToNumber e.Numbers1>) <SymbolsToNumber e.Numbers2>> : e.Result
        = <NumberToSymbols e.Result> : e.Result^
        =
        (
          (e.Result) (()()) ()
        );

      (ColdCallBrackets (Symbol Name e.Name) e.Body) (Symbol Number 1),
      <OneOf (e.Name) <ArithmeticFunctions>> : True =
      (
        ((ColdCallBrackets (Symbol Name e.Name) e.Body)) (()()) ()
      );

      (Symbol Number 1) (ColdCallBrackets (Symbol Name e.Name) e.Body),
      <OneOf (e.Name) <ArithmeticFunctions>> : True =
      (
        ((ColdCallBrackets (Symbol Name e.Name) e.Body)) (()()) ()
      );

      e.Sign1 (Symbol Number s.1) e.Sign2 (Symbol Number s.2) =
      e.Sign1 : {
        (Symbol Char s.sign1)
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Mul s.sign1 s.1 s.sign2 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>;

            = <Mul s.sign1 s.1 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>
        };
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Mul s.1 s.sign2 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>;

            = (
              ((Symbol Number <Mul s.1 s.2>)) (()()) ()
            )
        }
      };

      e._  = <MakeColdSolution t.IntrinsicFunction e.Args>
    };

    'Div' = e.Args : {
        (Brackets e.Numbers1) e.Numbers2
        = <Div (<SymbolsToNumber e.Numbers1> ) <SymbolsToNumber e.Numbers2>> : e.Result
        = <NumberToSymbols e.Result> : e.Result^
        =
        (
          (e.Result) (()()) ()
        );

        (ColdCallBrackets (Symbol Name e.Name) e.Body) (Symbol Number 1),
        <OneOf (e.Name) <ArithmeticFunctions>> : True =
        (
          ((ColdCallBrackets (Symbol Name e.Name) e.Body)) (()()) ()
        );

        e.Sign1 (Symbol Number s.1) e.Sign2 (Symbol Number s.2) =
        e.Sign1 : {
          (Symbol Char s.sign1)
          = e.Sign2 : {
            (Symbol Char s.sign2)
              = <Div s.sign1 s.1 s.sign2 s.2> : e.ResSign s.Res
              = <SignedArithmeticResult s.Res e.ResSign>;

              = <Div s.sign1 s.1 s.2> : e.ResSign s.Res
              = <SignedArithmeticResult s.Res e.ResSign>
          };
          = e.Sign2 : {
            (Symbol Char s.sign2)
              = <Div s.1 s.sign2 s.2> : e.ResSign s.Res
              = <SignedArithmeticResult s.Res e.ResSign>;

              = <Div s.1 s.2> : e.ResSign s.Res
              = <SignedArithmeticResult s.Res e.ResSign>
          }
        };

        e._  = <MakeColdSolution t.IntrinsicFunction e.Args>
    };

    'Mod' = e.Args : {
      (Brackets e.Numbers1) e.Numbers2
        = <Mod (<SymbolsToNumber e.Numbers1>) <SymbolsToNumber e.Numbers2>> : e.Result
        = <NumberToSymbols e.Result> : e.Result^
        =
        (
          (e.Result) (()()) ()
        );

      e.Sign1 (Symbol Number s.1) e.Sign2 (Symbol Number s.2) =
      e.Sign1 : {
        (Symbol Char s.sign1)
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Mod s.sign1 s.1 s.sign2 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>;

            = <Mod s.sign1 s.1 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>
        };
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Mod s.1 s.sign2 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>;

            = <Mod s.1 s.2> : e.ResSign s.Res
            = <SignedArithmeticResult s.Res e.ResSign>
        }
      };

      e._  = <MakeColdSolution t.IntrinsicFunction e.Args>
    };

    'Divmod' = e.Args : {
      (Brackets e.Numbers1) e.Numbers2 =
        <Divmod (<SymbolsToNumber e.Numbers1>) <SymbolsToNumber e.Numbers2>> : (e.Q) e.R
        = <NumberToSymbols e.Q> : e.Q^
        = <NumberToSymbols e.R> : e.R^
        =
        (
          ((Brackets e.Q) e.R) (()()) ()
        );

      (ColdCallBrackets (Symbol Name e.Name) e.Body) (Symbol Number 1),
      <OneOf (e.Name) <ArithmeticFunctions>> : True =
      (
        ((Brackets (ColdCallBrackets (Symbol Name e.Name) e.Body)) (Symbol Number 0)) (()()) ()
      );

      (Symbol Number s.1) (Symbol Number s.2) =
      <Divmod s.1 s.2> : (s.Q) s.R
      =
      (
        ((Brackets (Symbol Number s.Q)) (Symbol Number s.R)) (()()) ()
      );

      e.Sign1 (Symbol Number s.1) e.Sign2 (Symbol Number s.2) =
      e.Sign1 : {
        (Symbol Char s.sign1)
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Divmod s.sign1 s.1 s.sign2 s.2> : (e.Q) e.R
            = <SignedResult-Divmod (e.Q) e.R>;

            = <Divmod s.sign1 s.1 s.2> : (e.Q) e.R
            = <SignedResult-Divmod (e.Q) e.R>
        };
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Divmod s.1 s.sign2 s.2> : (e.Q) e.R
            = <SignedResult-Divmod (e.Q) e.R>;

            = <Divmod s.1 s.2> : (e.Q) e.R
            = <SignedResult-Divmod (e.Q) e.R>
        }
      };

      e._  = <MakeColdSolution t.IntrinsicFunction e.Args>
    };

    'Compare' = e.Args : {
      (Brackets e.Numbers1) e.Numbers2
      = <Compare (<SymbolsToNumber e.Numbers1>) <SymbolsToNumber e.Numbers2>> : s.Result
      = (
        ((Symbol Char s.Result)) (()()) ()
      );

      e.Sign1 (Symbol Number s.1) e.Sign2 (Symbol Number s.2) =
      e.Sign1 : {
        (Symbol Char s.sign1)
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Compare s.sign1 s.1 s.sign2 s.2>;

            = <Compare s.sign1 s.1 s.2>
        };
        = e.Sign2 : {
          (Symbol Char s.sign2)
            = <Compare s.1 s.sign2 s.2>;

            = <Compare s.1 s.2>
        }
      } : s.Result
      = (
        ((Symbol Char s.Result)) (()()) ()
      );

      e._  = <MakeColdSolution t.IntrinsicFunction e.Args>
    };

    'Chr', <CheckArgs-Intrinsic-StaticSubstitution (e.Args) Number> : True
    = <StaticSubstitution (e.Args) ('Chr') &Chr Number Char> : e.Substitution
    = (
      (e.Substitution) (()()) ()
    );

    'Ord', <CheckArgs-Intrinsic-StaticSubstitution (e.Args) Char> : True
    = <StaticSubstitution (e.Args) ('Ord') &Ord Char Number> : e.Substitution
    = (
      (e.Substitution) (()()) ()
    );

    'Upper', <CheckArgs-Intrinsic-StaticSubstitution (e.Args) Char> : True
    = <StaticSubstitution (e.Args) ('Upper') &Upper Char Char> : e.Substitution
    = (
      (e.Substitution) (()()) ()
    );

    'Lower', <CheckArgs-Intrinsic-StaticSubstitution (e.Args) Char> : True
    = <StaticSubstitution (e.Args) ('Lower') &Lower Char Char> : e.Substitution
    = (
      (e.Substitution) (()()) ()
    );

    'Numb'
    , <CheckArgs-Intrinsic (e.Args) Char> : True
      = <NodeToChar e.Args> : e.Chars
      = <NumberToSymbols <Numb e.Chars>> : e.Result
      = (
        (e.Result) (()()) ()
      );

    'Symb'
    , <CheckArgs-Intrinsic-Symb e.Args> : True
      = <Symb <SymbolsToNumber e.Args>> : e.Numbers
      = <CharToNode e.Numbers> : e.Result
      = (
        (e.Result) (()()) ()
      );

    'Implode'
    , <CheckArgs-Intrinsic (e.Args) Char> : True
      = <NodeToChar e.Args> : e.Chars
      = (
        ((Symbol Identifier e.Chars)) (()()) ()
      );

    'Implode_Ext'
    , <CheckArgs-Intrinsic (e.Args) Char> : True
      = <NodeToChar e.Args> : e.Chars
      = (
        ((Symbol Identifier e.Chars)) (()()) ()
      );

    'Explode'
    , <CheckArgs-Intrinsic (e.Args) Identifier> : True
      = e.Args : {
        (Symbol Identifier e.Name) = <CharToNode e.Name>
      } : e.Result
      = (
        (e.Result) (()()) ()
      );

    'Explode_Ext'
    , <CheckArgs-Intrinsic (e.Args) Identifier> : True
      = e.Args : {
        (Symbol Identifier e.Name) = <CharToNode e.Name>
      } : e.Result
      = (
        (e.Result) (()()) ()
      );

    'Type'
    = e.Args : {
      (Symbol Number s.Num) e.Rest =
      <Type s.Num> : s.Type s.SubType e._
      = <CharToNode s.Type s.SubType> : e.Result
      = (
        (e.Result (Symbol Number s.Num) e.Rest) (()()) ()
      );

      (Symbol Char s.Char) e.Rest =
      <Type s.Char> : s.Type s.SubType e._
      = <CharToNode s.Type s.SubType> : e.Result
      = (
        (e.Result (Symbol Char s.Char) e.Rest) (()()) ()
      );

      (Symbol Identifier e.Name) e.Rest =
      <Type <Implode e.Name>> : s.Type s.SubType e._
      = <CharToNode s.Type s.SubType> : e.Result
      = (
        (e.Result (Symbol Identifier e.Name) e.Rest) (()()) ()
      );
    };

    'Lenw'
    , <CheckArgs-Intrinsic-EVariable e.Args> : True
    = <Lenw e.Args> : s.Len e._
    = (
      ((Symbol Number s.Len) e.Args) (()()) ()
    );

    'First'
    = e.Args : {
      (Symbol Number s.N) e.Expr
      , <CheckArgs-Intrinsic-EVariable e.Expr> : True
      = <First s.N e.Expr> : (e.Prefix) e.Suffix
      = (
        ((Brackets e.Prefix) e.Suffix) (()()) ()
      );

      e._ = <MakeColdSolution t.IntrinsicFunction e.Args>
    };

    'Last'
    = e.Args : {
      (Symbol Number s.N) e.Expr
      , <CheckArgs-Intrinsic-EVariable e.Expr> : True
      = <Last s.N e.Expr> : (e.Prefix) e.Suffix
      = (
        ((Brackets e.Prefix) e.Suffix) (()()) ()
      );

      e._ = <MakeColdSolution t.IntrinsicFunction e.Args>
    };

    e._ = <MakeColdSolution t.IntrinsicFunction e.Args>
  }
}

/* 
  <OptSentence-MakeSubstitutions
    t.Mode (e.OriginSentence) (e.CallArgs) t.OptFunction t.Metatable
  >
    == (e.SolutionsPack)*
  e.SolutionsPack ::= (e.ReplacedExpr) t.Solution* (e.NewFunctions)
  t.Solution ::= (e.Contractions) (e.Assignments)
*/
OptSentence-MakeSubstitutions {
  (s.DriveMode Intrinsic)
  ((e.Left) (e.Expr)) (e.Args)
  (Intrinsic s.ScopeClass (e.IntrinsicName) Intrinsic e.BehaviorName) t.Metatables
    = (Intrinsic s.ScopeClass (e.IntrinsicName) Intrinsic e.BehaviorName) : t.IntrinsicFunction
    = <DoOptSentence-MakeSubstitutions-Intrinsic t.IntrinsicFunction t.Metatables (e.Args) e.BehaviorName>;

  t.Mode
  ((e.Left) (e.Expr)) (e.Args)
  t.Function t._
    /* Активные вызовы игнорируем */
    , <IsPassiveCall e.Args> : False

    = <MakeColdSolution t.Function e.Args>;

  (s.DriveMode s.IntrinsicMode)
  ((e.Left) (e.Expr)) (e.Args)
  (s.FuncMode s.ScopeClass (e.Name) Sentences e.Body) t._
    , <OneOf s.DriveMode Drive Inline> : True

    /* Если левая часть не L-выражение, допускаем только встраивание */
    = <IsLexpr e.Left>
    : {
        True = s.DriveMode;
        False = Inline;
      }
    : s.DriveMode^

    = <ExtractVariables ((e.Left) (e.Expr))> : e.SentenceVars
    = <DecreaseMode s.DriveMode s.FuncMode> : s.DriveMode^

    = <DoOptSentence-MakeSubstitutions
      s.DriveMode (e.SentenceVars) (e.Args)
        (/* substitutions */)
        (Function s.ScopeClass (e.Name) Sentences e.Body)
      >;

  t.Mode
  ((e.Left) (e.Expr)) (e.Args)
  t.Function t._
    = <MakeColdSolution t.Function e.Args>;
}

MakeColdSolution {
  (s.FuncMode s.ScopeClass (e.Name) s.BodyLabel e.Body) e.Args
    , e.Name : e.Prefix '*' s.Num
    = (
        ((ColdCallBrackets (Symbol Name e.Name) e.Args))
        ((/* нет присваиваний */) (/* нет сужений */))
        ((NewFunction s.ScopeClass (e.Name) s.BodyLabel e.Body))
      );

  (s.FuncMode s.ScopeClass (e.Name) s.BodyLabel e.Body) e.Args
    = (
        ((ColdCallBrackets (Symbol Name e.Name) e.Args))
        ((/* нет присваиваний */) (/* нет сужений */))
        (/* нет новых функций */)
      );
}

DecreaseMode {
  Inline s.Mode = Inline;
  Drive s.Mode = s.Mode;
}

DoOptSentence-MakeSubstitutions {
  s.Mode (e.SentenceVars) (e.Args) (e.Substitutions)
  (Function s.ScopeClass (e.Name) Sentences ((e.LS) (e.RS)) e.Rest)
    = <Solve (e.SentenceVars) ((e.Args) ':' (e.LS))>
    : {
        /*
          В случае решения без сужений просто применяем замены
        */
        Success (() (e.Assigns))
          = e.Substitutions
            ((e.RS) (() (e.Assigns)) (/* нет новых функций */));

        /*
          «Грязное» решение допускаем только в случае прогонки
        */
        Success e.M
          , s.Mode : Drive
          = <DoOptSentence-MakeSubstitutions
              s.Mode (e.SentenceVars) (e.Args)
              (
                e.Substitutions
                ((e.RS) e.M (/* нет новых функций */))
              )
              (Function
                GN-Local (<RemainderFuncIncName e.Name>) Sentences e.Rest
              )
            >;

        /*
          При неудаче переходим к следующему предложению, к подстановкам
          ничего не добавляем
        */
        Failure
          = <DoOptSentence-MakeSubstitutions
              s.Mode (e.SentenceVars) (e.Args) (e.Substitutions)
              (Function
                GN-Local (<RemainderFuncIncName e.Name>) Sentences e.Rest
              )
            >;

        /*
          Здесь либо Undefined, либо грязное решение в режиме встраивания,
          в обоих случаях добавляем холодный вызов остаточной функции
        */
        e.Other
          = e.Substitutions
            <MakeColdSolution
              (Function s.ScopeClass (e.Name) Sentences ((e.LS) (e.RS)) e.Rest)
              e.Args
            >;
      };

  s.Mode (e.SentenceVars) (e.Args) (e.Substitutions) t.RestFunction
    = e.Substitutions <MakeColdSolution t.RestFunction e.Args>;
}

DropLeft {
  e.List 0 =  e.List;
  t.Head e.Tail s.N = <DropLeft e.Tail <Sub s.N 1>>
}

/*
  <FindOptInfo e.OptFuncs (e.Name)> == e.OptFuncs t.Function
  t.Function ::= (s.Mode s.ScopeClass (e.Name) e.Body)
*/
FindOptInfo {
  e.OptFuncs (e.Name)
    = e.Name
    : {
        e.Prefix '*' s.N = <CutSUF e.Prefix> s.N;
        e.Name^ = e.Name 0;
      }
    : e.LookupName s.Drop
    = <FindOptInfo-Aux e.OptFuncs (e.Name) (e.LookupName) s.Drop>;
}

FindOptInfo-Aux {
  e.OptFuncs-B (Intrinsic s.ScopeClass (e.LookupName) e.Body) e.OptFuncs-E
  (e.Name) (e.LookupName) s._
  = e.OptFuncs-B (Intrinsic s.ScopeClass (e.LookupName) e.Body) e.OptFuncs-E
    (Intrinsic s.ScopeClass (e.Name) e.Body);
  
  e.OptFuncs-B (s.Mode s.ScopeClass (e.LookupName) e.Body) e.OptFuncs-E
  (e.Name) (e.LookupName) s.Drop
    = e.Body : Sentences e.Sentences
    = e.OptFuncs-B (s.Mode s.ScopeClass (e.LookupName) e.Body) e.OptFuncs-E
      (s.Mode s.ScopeClass (e.Name) Sentences <DropLeft e.Sentences s.Drop>);

  e.Other = ()
}

$DRIVE CutSUF;

CutSUF {
  e.Prefix SUF = e.Prefix;
  e.Prefix = e.Prefix;
}

FindMetatables {
  e.OptFuncs = <MapAccum
    {
      (e.Result) (Metatable e.Body) = (e.Result (Metatable e.Body));
      (e.Result) t.Other = (e.Result)
    } () e.OptFuncs>
    : (e.Metatables) e._
  = (e.Metatables)
}

/*
  <FindOptimizedCall (e.OptFuncNames) e.Expr>
    == (e.OptFuncNames t.Found) e.Expr

  t.Found ::= None | (CallBrackets e.Arg)
*/

FindOptimizedCall {
  (e.OptFuncNames) e.Expr
    = <MapAccum &FindOptimizedCall-Term (e.OptFuncNames None) e.Expr>;
}

FindOptimizedCall-Term {
  (e.OptFuncNames None) (Brackets e.Expr)
    = <FindOptimizedCall (e.OptFuncNames) e.Expr>
    : (e.OptFuncNames^ t.Found) e.Expr^
    = (e.OptFuncNames t.Found) (Brackets e.Expr);

  (e.OptFuncNames None) (ADT-Brackets (e.Name) e.Expr)
    = <FindOptimizedCall (e.OptFuncNames) e.Expr>
    : (e.OptFuncNames^ t.Found) e.Expr^
    = (e.OptFuncNames t.Found)
      (ADT-Brackets (e.Name) e.Expr);

  (e.OptFuncNames None) (CallBrackets (Symbol Name e.Name) e.Arg)
    = <FindOptimizedCall (e.OptFuncNames) e.Arg>
    : {
*       Вызов оптимизируемой функции, извлекаем его наружу
        (e.OptFuncNames-B (e.Name) e.OptFuncNames-E None) e.Arg^
          = (
              e.OptFuncNames-B (e.Name) e.OptFuncNames-E
              (CallBrackets (Symbol Name e.Name) e.Arg)
            )
            (TkVariable 'e' DRIVEN 0);

*       Функция, не подлежащая оптимизации. Остужаем вызов.
        (e.OptFuncNames^ None) e.Arg^
          = e.Name : {
            '__Step-Drop' = (e.OptFuncNames None);
            e._ = (e.OptFuncNames None)
            (ColdCallBrackets (Symbol Name e.Name) e.Arg);
          };

*       Внутри аргумента найден оптимизируемый вызов
        (e.OptFuncNames^ t.Found) e.Arg^
          = (e.OptFuncNames t.Found)
            (CallBrackets (Symbol Name e.Name) e.Arg);
      };

  (e.OptFuncNames None) (CallBrackets e.Expr)
    = <FindOptimizedCall (e.OptFuncNames) e.Expr>
    : (e.OptFuncNames^ t.Found) e.Expr^
    = (e.OptFuncNames t.Found) (CallBrackets e.Expr);

  (e.OptFuncNames t.Found) t.AnyTerm
    = (e.OptFuncNames t.Found) t.AnyTerm;
}

/*
  <ApplySolutions
    ((e.Left) (e.Right)) (e.LS) (e.Solutions)
  > == t.Sentence* t.FunctionInfo
*/

ApplySolutions {
  ((e.Left) (e.Right)) (e.RS) e.Solutions
    = <Map
        {
          t.S = <ApplySolution ((e.Left) (e.Right)) (e.RS) t.S>
        }
        e.Solutions
      >
}

/*
  <ApplySolution
    ((e.Left) (e.Right)) (e.LS) (e.Contrs) (e.Assigns)
  > == t.Sentence
*/

ApplySolution {
  ((e.Left) (e.Right)) (e.RS) ((e.Contrs) (e.Assigns))
    = <ApplyAssigns e.RS (e.Assigns)>: e.CallReplacer
    = e.Contrs ((TkVariable 'e' DRIVEN 0) ':' e.CallReplacer): e.Contrs^
    = ((<ApplyContractions e.Left (e.Contrs)>)
       (<ApplyContractions e.Right (e.Contrs)>));
}

/*
  <ApplyAssigns (e.Expr) (e.Assigns)> == e.Expr^
*/

ApplyAssigns {
  e.Expr (e.Assigns)
    = <Map
        {
          t.T = <ApplyAssigns-Term t.T (e.Assigns)>
        }
        e.Expr
      >
}

ApplyAssigns-Term {
  (Brackets e.Expr) (e.Assigns) = (Brackets <ApplyAssigns e.Expr (e.Assigns)>);

  (CallBrackets e.Args) (e.Assigns)
    = (CallBrackets <ApplyAssigns e.Args (e.Assigns)>);

  (ColdCallBrackets e.Args) (e.Assigns)
    = (ColdCallBrackets <ApplyAssigns e.Args (e.Assigns)>);

  (ClosureBrackets e.Args) (e.Assigns)
    = (ClosureBrackets <ApplyAssigns e.Args (e.Assigns)>);

  (ADT-Brackets (e.Name) e.Expr) (e.Assigns)
    = (ADT-Brackets (e.Name) <ApplyAssigns e.Expr (e.Assigns)>);

  t.T (e.B (e.Asgn ':' t.T) e.E)
    =  e.Asgn;

  t.T (e.Assigns) = t.T;
}

/*
  <ApplyContractions (e.Expr) (e.Contrs) == e.Expr^
*/
ApplyContractions {
  e.Expr (e.Contrs)
    = <Map
        {
          t.T = <ApplyContractions-Term t.T (e.Contrs)>
        }
        e.Expr
      >;
}

ApplyContractions-Term {
  (Brackets e.Expr) (e.Contrs)
    = (Brackets <ApplyContractions e.Expr (e.Contrs)>);

  (CallBrackets e.Args) (e.Contrs)
    = (CallBrackets <ApplyContractions e.Args (e.Contrs)>);

  (ColdCallBrackets e.OriginArgs) (e.Contrs)
    = <ApplyContractions e.OriginArgs (e.Contrs)>
    : {
*       Содержимое холодных скобок не изменилось, оставляем их холодными
        e.OriginArgs = (ColdCallBrackets e.OriginArgs);

*       Содержимое обновилось, оттаиваем скобки
        e.ChangedArgs = (CallBrackets e.ChangedArgs);
      };

  (ClosureBrackets e.Args) (e.Contrs)
    = (ClosureBrackets <ApplyContractions e.Args (e.Contrs)>);

  (ADT-Brackets (e.Name) e.Expr) (e.Contrs)
    = (ADT-Brackets (e.Name) <ApplyContractions e.Expr (e.Contrs)>);

  t.Term (e.B (t.Term ':' e.Contr) e.E)
    = <ApplyContractions e.Contr (e.B (t.Term ':' e.Contr) e.E)>;

  t.T (e.Contrs) = t.T
}

/*
  <RemainderFuncIncName e.Name> == e.Name
*/

RemainderFuncIncName {
  e.Name SUF e.Suffixes '*' s.N = e.Name SUF e.Suffixes '*' <Add s.N 1>;

  e.Name SUF e.Suffixes = e.Name SUF e.Suffixes '*' 1;

  e.Name = e.Name SUF '*' 1;
}

/**
  <OptTree-Drive-CleanupColdCalls e.AST> == e.AST^
*/
$ENTRY OptTree-Drive-CleanupColdCalls {
  e.AST
    = <Map
        {
          (Function s.ScopeClass (e.Name) Sentences e.Body)
            = (Function
                s.ScopeClass (e.Name) Sentences <CleanupCold-Body e.Body>
              );

          t.OtherItem = t.OtherItem;
        }
        e.AST
      >;
}

CleanupCold-Body {
  e.Sentences = <Map &CleanupCold-Sentence e.Sentences>;
}

CleanupCold-Sentence {
  ((e.Pattern) e.Conditions (e.Result))
    = (
        (e.Pattern)
        <Map
          {
            (Condition (e.Name) (e.Result^) (e.Pattern^))
              = (Condition
                  (e.Name) (<CleanupCold-Result e.Result>) (e.Pattern)
                );
          }
          e.Conditions
        >
        (<CleanupCold-Result e.Result>)
      );
}

CleanupCold-Result {
  e.Result = <Map &CleanupCold-Term e.Result>;
}

CleanupCold-Term {
  (Brackets e.Expr) = (Brackets <CleanupCold-Result e.Expr>);

  (ADT-Brackets (e.Name) e.Expr)
    = (ADT-Brackets (e.Name) <CleanupCold-Result e.Expr>);

  (CallBrackets e.Expr) = (CallBrackets <CleanupCold-Result e.Expr>);
  (ColdCallBrackets e.Expr) = (CallBrackets <CleanupCold-Result e.Expr>);

  t.OtherTerm = t.OtherTerm;
}
