$INCLUDE "LibraryEx";

*$FROM Error
$EXTERN PrintErr;

*$FROM GenericMatch
$EXTERN GenericMatch;

*$FROM Desugaring
$EXTERN CreateContext, RemovePos-Expr, ExtractVariables-Expr,
        Pass-EnumerateVariables, Pass-RemovePos;

/*
  CheckScreening выводит стандартизированные сообщения об экранировании.
*/
$ENTRY CheckScreening {
 (e._ screening e._) (e.AST)
   = <FindFunctionsPosInAST e.AST> : (e.FunctionsPos) e.AST^
   = <Pass-RemovePos e.AST> : e.AST^
   = <Pass-EnumerateVariables e.AST> : e.AST^
   = <Zip (e.AST) (e.FunctionsPos)> : e.FunctionsWithPos
   = <Map &CheckFunction e.FunctionsWithPos>;

 (e._) (e.AST) = /* пусто */
}

Zip {
  (t.L e.L) (t.R e.R) = (t.L t.R) <Zip (e.L) (e.R)>;
  () () = /* пусто */;
}

FindFunctionsPosInAST {
  e.AST
    = <MapAccum
        {
          (e.Positions)
          (Function t.SrcPos s.ScopeClass (e.Name) Sentences e.Sentences)
            = (e.Positions t.SrcPos)
             (Function t.SrcPos s.ScopeClass (e.Name) Sentences e.Sentences);

          (e.Positions) t.Other = (e.Positions) /* пусто */
        }
        () e.AST
      >;
}

/*
  MakePairs создает "декартовы" пары для дальнейшей попарной проверки
  алгоритмом обобщенного сравнивания.

  Считаем, что предложение с условием не экранирует,
  но может экранироваться само.
*/
MakePairs {
  t.NumberedSentence e.Tail
    = <Map
        {
          t.NumberedSentenceTail = (t.NumberedSentenceTail t.NumberedSentence);
        }
        e.Tail
      >
      <MakePairs e.Tail>;

  /* пусто */ = /* пусто */;
}

/*
  <Enumerate t.Item*>
    == (t.Item-1 1) (t.Item-2 2) ... (t.Item-N N)
*/
Enumerate {
  e.Items
    = <MapAccum
        {
          s.Count t.Item = <Inc s.Count> (t.Item s.Count);
        }
        1 e.Items
      >
    : s._ e.NumberedItems = e.NumberedItems
}

CheckFunction {
  ((Function s.ScopeClass (e.Name) Sentences e.Sentences) t.SrcPos)
    = <CheckSentences t.SrcPos (e.Name) () () (e.Sentences)>
}

CheckSentences {
  t.SrcPos (e.FuncName) (e.Prefix) (e.ContextVars) (e.Sentences)
    = <Enumerate e.Sentences> : e.NumberedSentences
    = <MakePairs e.NumberedSentences> : e.NumberedSentencesPairs
    = <FilterConditions e.NumberedSentencesPairs> : e.NumberedSentencesPairs^
    = <CheckPatternPairs
        t.SrcPos
        (e.FuncName)
        (e.Prefix)
        (e.ContextVars)
        (e.NumberedSentencesPairs)
      >
      <DelAccumulator
        <MapAccum
          {
            s.Num ((e.Pattern) e.AssignsOrConds (e.Result) (e.Blocks))
              = e.Prefix '$' <Symb s.Num> : e.Prefix^
              = e.ContextVars e.Pattern : e.ContextVars^
              = <Map
                  {
                    (s.AssignOrCond (e.Result^) (e.Blocks^) (e.Pattern^))
                      = e.Pattern;
                  }
                  e.AssignsOrConds
                >
              : e.ContextAllAssignsOrConds
              = <Inc s.Num>
                <CheckSentenceAssignsAndConditions
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix)
                  (e.ContextVars)
                  ((e.Pattern) e.AssignsOrConds (e.Result) (e.Blocks))
                >
                <CheckSentenceResult
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix)
                  (e.ContextVars e.ContextAllAssignsOrConds)
                  ((e.Pattern) e.AssignsOrConds (e.Result) (e.Blocks))
                >
                <CheckSentenceBlocks
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix)
                  (e.ContextVars e.ContextAllAssignsOrConds)
                  ((e.Pattern) e.AssignsOrConds (e.Result) (e.Blocks))
                >
          }
          1 e.Sentences
        >
      >
}

CheckSentenceBlocks {
  t.SrcPos
  (e.FuncName)
  (e.Prefix)
  (e.ContextVars)
  ((e.SentencePattern) e._ (e._) (e.Blocks))
    = <CheckBlocks
        t.SrcPos
        (e.FuncName)
        (e.Prefix)
        (e.ContextVars)
        (e.Blocks)
      >;
}

CheckBlocks {
  t.SrcPos (e.FuncName) (e.Prefix) (e.ContextVars) (e.Blocks)
    = <DelAccumulator
        <MapAccum
          {
            s.Num (Sentences e.Sentences)
              = <Inc s.Num>
                <CheckSentences
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix ':' <Symb s.Num>)
                  (e.ContextVars)
                  (e.Sentences)
                >;

            s.Num t.OtherBlock = s.Num /* пусто */;
          }
          1 e.Blocks
        >
      >;
}


CheckSentenceAssignsAndConditions {
  t.SrcPos
  (e.FuncName)
  (e.Prefix)
  (e.ContextVars)
  ((e._) e.AssignsOrConditions (e._) (e._))
    = <DelAccumulator
        <MapAccum
          {
            (s.Num e.ContextVars^)
            (s.AssignOrCondition (e.Result) (e.Blocks) (e.Pattern))
              , s.AssignOrCondition
              : {
                  Assign = '=';
                  Condition = '?'
                }
              : s.AssignOrCondition^
              = e.Prefix s.AssignOrCondition <Symb s.Num> : e.Prefix^
              = (<Inc s.Num> e.ContextVars e.Pattern)
                <CheckBlocks
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix)
                  (e.ContextVars)
                  (e.Blocks)
                >
                <CheckExpression
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix)
                  (e.ContextVars)
                  (e.Result)
                >;

            (s.Num e.ContextVars^) t.Other = (s.Num e.ContextVars) /* пусто */;
          }
          (1 e.ContextVars) e.AssignsOrConditions
        >
      >;
}

CheckSentenceResult {
  t.SrcPos (e.FuncName) (e.Prefix) (e.ContextVars) ((e._) e._ (e.Result) (e._))
    = <CheckExpression
        t.SrcPos
        (e.FuncName)
        (e.Prefix)
        (e.ContextVars)
        (e.Result)
      >
}

CheckSentencePattern {
  t.SrcPos (e.FuncName) (e.Prefix) (e.ContextVars) ((e.Pattern) e._ (e._) (e._))
    = <CheckExpression
        t.SrcPos
        (e.FuncName)
        (e.Prefix)
        (e.ContextVars)
        (e.Pattern)
      >
}

CheckExpression {
  t.SrcPos (e.FuncName) (e.Prefix) (e.ContextVars) (e.Expression)
    = <DelAccumulator
        <MapAccum
          {
            s.Num (Brackets e.Expr)
              = s.Num
                <CheckExpression
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix)
                  (e.ContextVars)
                  (e.Expr)
                >;
            s.Num (ADT-Brackets t._ (e._) e.Expr)
              = s.Num
                <CheckExpression
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix)
                  (e.ContextVars)
                  (e.Expr)
                >;
            s.Num (CallBrackets e.Expr)
              = s.Num
                <CheckExpression
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix)
                  (e.ContextVars)
                  (e.Expr)
                >;
            s.Num (Closure Sentences e.Sentences)
              = <Inc s.Num>
                <CheckSentences
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix '\\' <Symb s.Num>)
                  (e.ContextVars)
                  (e.Sentences)
                >;

            s.Num t.Other = s.Num /* пусто */
          }
          1 e.Expression
        >
      >
}

CheckPatternPairs {
  t.SrcPos (e.FuncName) (e.Prefix) (e.ContextVars) (e.Pairs)
    = <Map
      {
        (
          (((e.Pattern-L) e._ (e._) (e._)) s.Num-L)
          (((e.Pattern-R) e._ (e._) (e._)) s.Num-R)
        )
          = <Unique <ExtractVariables-Expr e.ContextVars>> : e.ContextVars^
          = <CreateContext NoMarkupContext e.ContextVars> : e.ContextVars^
          = <GenericMatch
              (e.ContextVars e.Pattern-L)
              (e.ContextVars e.Pattern-R)
            >
          : {
            e._
              , (e.Pattern-L) (e.Pattern-R)
              : () ()
              = <CreateScreeningWarning
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix '$' <Symb s.Num-R>)
                  (e.Prefix '$' <Symb s.Num-L>)
                >;
            Clear e._
              = <CreateScreeningWarning
                  t.SrcPos
                  (e.FuncName)
                  (e.Prefix '$' <Symb s.Num-R>)
                  (e.Prefix '$' <Symb s.Num-L>)
                >;

            e._ = /* пусто */;
          };
      }
      e.Pairs
    >;

  /* пусто */ = /* пусто */;
}


FilterConditions {
  e.NumberedSentencesPairs
    = <Map
        {
          (t.NumberedSentence-L (((e._) (Condition e.Cond) e._) s._))
            = /* пусто */;

          t.OtherPair = t.OtherPair;
        }
        e.NumberedSentencesPairs
      >;
}

CreateScreeningWarning {
  t.SrcPos (e.FunName) (e.Screening) (e.Screened)
    = (Warning
        screening
        t.SrcPos
        Screening
        (e.FunName)
        (e.Screening)
        (e.Screened)
      )
}

